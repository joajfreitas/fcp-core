/*
 * CAN-IDS template for FST10e
 * Copyright © 2019 João Freitas
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 *
 * --------------------------------------------------------------------------
 *
 * This file was automatically generated in {{date}}
 * 
 */

#ifndef NO_{{device.name.upper()}}

#ifndef __{{device.name.upper()}}_CAN_H
#define __{{device.name.upper()}}_CAN_H

#include <stdint.h>
#include "candata.h"
#include "signal_parser.h"

{% if device.msgs.values() | length != 0 %}
/* Messages */
{% endif %}
{%- for message in device.msgs.values() %}
#define MSG_ID_{{device.name.upper()}}_{{message.name.upper()}} {{message.id}}
{%- endfor %}

{% if device.cmds.values() | length != 0 %}
/* Commands */
{% endif %}
{%- for cmd in device.cmds.values() %}
#define CMD_{{device.name.upper()}}_{{cmd.name.upper()}} {{cmd.id}}
{%- endfor %}

{% if device.cfgs.values() | length != 0 %}
/* Configs */
{% endif %}
{%- for cfg in device.cfgs.values() %}
#define CFG_{{device.name.upper()}}_{{cfg.name.upper()}} {{cfg.id}}
{%- endfor %}

#define CFG_{{device.name.upper()}}_SIZE {{device.cfgs.values()|length}}

extern const char *cfg_{{device.name}}_names[];

/* Message Structures */
{% for message in device.msgs.values() %}
{%- if message.comment != "" %}
/* {{message.comment}} */
{%- endif%}
typedef struct _{{message.type.lower()}} {
	{%- for signal in message.signals.values() %}
	{%- if signal.comment != "" or signal.unit != None%}
	/*{{signal.comment}} [{{signal.unit}}]*/
	{%- endif%}
	{%- if signal.mux_count > 1 %}
	{{signal.dst_type}} {{signal.name}}[{{signal.mux_count}}]; 
	{%- else %}
	{{signal.dst_type}} {{signal.name}}; 
	{%- endif %}
	{%- endfor %}
} {{message.type.lower()}}; 
{% endfor %}

/* Device Structure */
typedef struct _{{device.signature.lower()}} {
{%- for message in device.msgs.values() %}
	{{message.type.lower()}} {{message.name.lower()}};
{%- endfor %}
} {{device.signature.lower()}};

/* Decode Signals */
{%- for message in device.msgs.values() %}
/* {{message.name}} */
{%- for signal in message.signals.values() %}
#define decode_{{message.name.lower()}}_{{signal.name}}(msg) decode_signal_{{signal.type}}_as_{{signal.dst_type}}((msg), {{signal.start}}, {{signal.length}}, {{signal.scale}}, {{signal.offset}});
{%- endfor %}
{% endfor %}
/* Decode messages */
{% for message in device.msgs.values() %}
{{message.type.lower()}} decode_{{message.name.lower()}}(CANdata msg);
{%- endfor %}

void decode_{{device.name}}(CANdata msg, {{device.signature}} *dev);

/* Encode signals*/ 
{%- for message in device.msgs.values() %}
/* {{message.name}} */
{%- for signal in message.signals.values() %}
#define encode_{{message.name.lower()}}_{{signal.name}}(signal) encode_signal_{{signal.type}}_from_{{signal.dst_type}}((signal), {{signal.start}}, {{signal.length}}, {{signal.scale}}, {{signal.offset}});
{%- endfor %}
{%- endfor %}

/* Encode messages */
{% for message in device.msgs.values() %}
{% if message.mux_count == 0 %}
CANdata encode_{{message.name.lower()}}({{message.type.lower()}});
{% else %}
	CANdata encode_{{message.name.lower()}}({{message.type.lower()}}, uint32_t {{message.multiplexor}});
{% endif %}
{%- endfor %}

/** @fn {{device.name}}_send_msgs({{device.signature}} dev, uint32_t time)
 *  @brief Send messages periodically.
 *  @param dev Device structure.
 *  @param time Timestamp in milliseconds.
 */
void {{device.name}}_send_msgs({{device.signature}} dev, uint32_t time);
#endif
#endif
