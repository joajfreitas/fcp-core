#ifndef __FCP_H__
#define __FCP_H__

#include <vector>
#include <cstdint>
#include <iostream>
#include <map>
#include <any>

namespace fcp {

{% for enum in fcp.enums -%}
enum {{enum.name}} {
    {% for enumeration in enum.enumeration -%}
    {{enumeration.name}} = {{enumeration.value}},
    {% endfor %}
};

{% endfor -%}

{% for struct, impl in structs -%}
struct {{struct.name}} {
    {% for signal in struct.fields -%}
    {{signal.type | to_cpp_type}} {{signal.name}};
    {% endfor -%}

    {% if impl is not none %}
    std::map<std::string, std::tuple<std::any, std::string>> to_dict() {
        std::map<std::string, std::tuple<std::any, std::string>> results{};

        {%- for piece in impl.encoding %}
        results["{{piece.name}}"] = std::make_tuple({{piece.name}}, "{{piece.type | to_cpp_type }}");
        {%- endfor -%}
        return results;
    }
    {% endif -%}

    {% if impl is not none %}
    static {{struct.name}} from_dict(std::map<std::string, std::tuple<std::any, std::string>> dict) {
        {{struct.name}} result{};
        {%- for piece in impl.encoding -%}

        {% set is_enum = piece.composite_type.is_some() %}
        result.{{piece.name}} = {%- if is_enum -%}static_cast<{{piece.composite_type.unwrap()}}>({%- endif -%}std::any_cast<{{piece.type | to_cpp_type}}>(std::get<0>(dict["piece.name"])){%- if is_enum -%}){%- endif -%};
        {%- endfor %}
        return result;
    }
    {% endif %}
};

inline bool operator==(const {{struct.name}}& lhs, const {{struct.name}}& rhs)
{
    return{% for signal in struct.fields %} lhs.{{signal.name}} == rhs.{{signal.name}} &&{% endfor %} true;
}

{% endfor -%}

std::vector<std::uint8_t> encode(uint8_t input) {
    return {input};
}

std::vector<std::uint8_t> encode(uint16_t input) {
    return {static_cast<uint8_t>((input >> 8) & 0xFF), static_cast<uint8_t>(input & 0xFF)};
}

std::vector<std::uint8_t> encode(uint32_t input) {
    return {
        static_cast<uint8_t>((input >> 24) & 0xFF),
        static_cast<uint8_t>((input >> 16) & 0xFF),
        static_cast<uint8_t>((input >>  8) & 0xFF),
        static_cast<uint8_t>((input >>  0) & 0xFF)
    };
}

{% for name, encoding in can_encodings.items() %}
std::vector<std::uint8_t> encode(const {{name}}& input) {
    std::vector<std::uint8_t> result{};
    std::vector<std::uint8_t> aux{};
    {%- for encode_piece in encoding.encoding | reverse %}
    {% set is_enum = encode_piece.composite_type.is_some() %}
    aux = encode({% if is_enum %}static_cast<{{encode_piece.type | to_cpp_type}}>({% endif %}input.{{encode_piece.name}}{% if is_enum %}){% endif %});
    result.insert(result.begin(), aux.rbegin(), aux.rend());
    {%- endfor %}
    return result;
}
{% endfor %}

uint8_t get_bit(const std::vector<uint8_t>& input, uint8_t bit) {
    auto byte_address = bit >> 3;
    auto intra_byte_bit_address = bit & 0b111;

    return (input[byte_address] >> intra_byte_bit_address) & 0b1;
}

template<typename T>
T _decode(const std::vector<uint8_t>&, uint8_t bitstart, uint8_t bitlength);

template<>
uint8_t _decode(const std::vector<uint8_t>& input, uint8_t bitstart, uint8_t bitlength) {
    uint8_t result = 0;

    for (int i=0; i<bitlength; i++) {
        result |= (get_bit(input, bitstart + i)) << i;
    }
    return result;
}

template<>
uint32_t _decode(const std::vector<uint8_t>& input, uint8_t bitstart, uint8_t bitlength) {
    uint32_t result = 0;

    for (int i=0; i<bitlength; i++) {
        result |= (get_bit(input, bitstart + i)) << i;
    }
    return result;
}

template<typename T>
T decode(const std::vector<uint8_t>&);

{% for name, can_encoding in can_encodings.items() %}
template<>
{{name}} decode(const std::vector<uint8_t>& input) {
    {{name}} result{};

    {%- for encode_piece in can_encoding.encoding -%}
    {% set is_enum = encode_piece.composite_type.is_some() %}
    result.{{encode_piece.name}} = 
    {%- if is_enum -%}
    static_cast<{{encode_piece.composite_type.unwrap()}}>(
    {%- endif -%} _decode<{{encode_piece.type | to_cpp_type()}}>(input, {{encode_piece.bitstart}}, {{encode_piece.bitlength}}){%- if is_enum -%}){%- endif -%};
    {%- endfor %}

    return result;
}
{% endfor -%}

} // namespace fcp

#endif // __FCP_CAN_H__
