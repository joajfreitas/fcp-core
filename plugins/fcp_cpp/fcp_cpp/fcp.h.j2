#ifndef __FCP_H__
#define __FCP_H__

#include <vector>
#include <cstdint>
#include <map>
#include <any>
#include <array>
#include <variant>
#include <memory>
#include <string>
#include <iostream>
#include <sstream>

namespace fcp {

namespace {

template<typename Iterator>
uint8_t get_bit(Iterator input, uint8_t bit) {
    auto byte_address = bit >> 3;
    auto intra_byte_bit_address = bit & 0b111;

    return (*(input+byte_address) >> intra_byte_bit_address) & 0b1;
}

class Buffer {
public:
    Buffer(std::size_t size): buffer_((size + 7)/8) {}
    Buffer(const std::vector<uint8_t>& buffer): buffer_{buffer} {}
    template<typename Iterator>
    Buffer(Iterator first, Iterator last): buffer_{first, last} {}


    uint64_t get_word(std::size_t bitstart, std::size_t bitlength) {
        uint64_t result = 0;
        for (int i=0; i<bitlength; i++) {
            result |= get_bit(buffer_.begin(), bitstart + i) << i;
        }

        return result;
    }

    template<typename T, std::size_t Size>
    void push_word(T word, std::size_t bitstart) {
        for (int i=0; i<Size; i++) {
            set_bit((word >> i) & 0b1, bitstart + i);
        }
    }

    std::vector<uint8_t> GetData() {
        return buffer_;
    }

private:
    void set_bit(uint8_t bit, std::size_t bit_index) {
        auto byte_address = bit_index >> 3;
        auto intra_byte_bit_address = bit_index & 0b111;

        buffer_[byte_address] = (buffer_[byte_address] & ~((uint8_t)1 << intra_byte_bit_address)) | ((uint8_t) bit << intra_byte_bit_address);

    }

private:
    std::vector<uint8_t> buffer_;
};
}

template<std::size_t Size>
class Uint8 {
public:
    Uint8(){}
    Uint8(std::uint8_t value): data_{value} {}

    Uint8(Buffer& buffer, std::size_t bitstart) {
        auto word = buffer.get_word(bitstart, Size);
        data_ = static_cast<std::uint8_t>(word);
    }

    void _encode(Buffer& buffer, std::size_t bitstart) {
        buffer.push_word<uint8_t, Size>(data_, bitstart) ;
    }

    static std::size_t GetSize() {
        return Size;
    }

    inline bool operator==(const Uint8& rhs) const
    {
        return true;
    }

    uint8_t GetData() const {
        return data_;
    }

    std::string to_string(std::string prefix = "") const {
        std::stringstream ss{};
        ss << (int) data_;
        return ss.str();
    }

private:
    std::uint8_t data_;
};

template<typename T, std::size_t N>
class Array {
    public:

    Array(): data_{} {}
    Array(std::array<T, N> value): data_{value} {}

    Array(Buffer& buffer, std::size_t bitstart=0) {
        for (int i=0; i<N; i++) {
            data_[i] = T(buffer, bitstart);
            bitstart += T::GetSize();
        }
    }

    void _encode(Buffer& buffer, std::size_t bitstart) {
        for (int i=0; i<N; i++) {
            data_[i]._encode(buffer, bitstart + i*T::GetSize());
        }
    }

    static std::size_t GetSize() {
        return N*T::GetSize();
    }

    const std::array<T,N>& GetData() const {
        return data_;
    }

    inline bool operator==(const Array& rhs) const
    {
        return GetData() == rhs.GetData();
    }

    std::string to_string(std::string prefix="") const {
        std::stringstream ss{};
        ss << "[";
        for (int i=0; i<N-1; i++){
            ss << data_[i].to_string() << ", ";
        }
        ss << data_[N-1].to_string() << "]";
        return ss.str();
    }


private:
    std::array<T, N> data_;
};


{% for enum in fcp.enums %}
template<typename Underlying>
class {enum.name} {
public:
    {% for enumeration in enum.enumeration %}
    static constexpr UnderlyingType {{enumeration.name}} = {{enumeration.value}};
    {% endfor %}

    {{enum.name}}(): data_{} {}
    {{enum.name}}(UnderlyingType value): data_{value} {}

    {{enum.name}}(Buffer& buffer, std::size_t bitstart=0) {
        data_ = buffer.get_word(bitstart, GetSize());
    }

    void _encode(Buffer& buffer, std::size_t bitstart) {
        buffer.push_word<UnderlyingType, GetSize()>(data_, bitstart);
    }

    static constexpr std::size_t GetSize() {
        return 2;
    }

    UnderlyingType GetData() const {
        return data_;
    }

    inline bool operator==(const {{enum.name}}& rhs) const {
        return GetData() == rhs.GetData();
    }

    std::string to_string(std::string prefix="") const {
        std::stringstream ss{};

        switch(GetData()) {
        {% for enumeration in enum.enumeration %}
            case {{enum.name}}::{{enumeration.name}}:
            return "{{enumeration.name}}";
        {% endfor %}
        default:
            return "DecodingError";
        }
    }

private:
    UnderlyingType data_;
}
{% endfor %}

//{% for struct, impl in structs %}
//struct {{struct.name}} {
//    {% for signal in struct.fields %}
//    using {{signal.name}}Type = 
//    {% endfor %}
//}
//{% endfor %}

///////////////////////////////////////////////////////////////////////////////


{% for struct, impl in structs -%}
struct {{struct.name}} {
    {% for signal in struct.fields -%}
    {{signal.type | to_cpp_type}} {{signal.name}};
    {% endfor -%}

    {% if impl is not none %}
    std::map<std::string, std::tuple<std::any, std::string>> to_dict() {
        std::map<std::string, std::tuple<std::any, std::string>> results{};

        {%- for piece in impl.encoding %}
        results["{{piece.name}}"] = std::make_tuple({{piece.name}}, "{{piece.type | to_cpp_type }}");
        {%- endfor -%}
        return results;
    }
    {% endif -%}

    {% if impl is not none %}
    static {{struct.name}} from_dict(std::map<std::string, std::tuple<std::any, std::string>> dict) {
        {{struct.name}} result{};
        {%- for piece in impl.encoding -%}

        {% set is_enum = piece.composite_type.is_some() %}
        result.{{piece.name}} = {%- if is_enum -%}static_cast<{{piece.composite_type.unwrap()}}>({%- endif -%}std::any_cast<{{piece.type | to_cpp_type}}>(std::get<0>(dict["piece.name"])){%- if is_enum -%}){%- endif -%};
        {%- endfor %}
        return result;
    }
    {% endif %}

    {% if impl is not none %}
    template<typename Iterator>
    static {{struct.name}} decode(Iterator input) {
        {{struct.name}} result{};
        {% for piece in impl.encoding %}
        {% if piece.type | is_enum %}
        _decode<Iterator>(({{piece | enum_underlying_type}} *) &result.{{piece.name}}, input, {{piece.bitstart}}, {{piece.bitlength}});
        {%- elif piece.type | is_builtin -%}
        _decode<Iterator>(&result.{{piece.name}}, input, {{piece.bitstart}}, {{piece.bitlength}});
        {% elif piece.type | is_array -%}
        result.{{piece.name}} = _decode_array<std::vector<uint8_t>::iterator, {{piece.type.type | to_cpp_type}}, {{piece.type.size}}>(input, {{piece.bitstart}}, {{(piece.bitlength / piece.type.size) | int}});
        {% endif -%}{% endfor %}

        return result;
    }
    {% endif %}

    {% if impl is not none %}
    std::vector<std::uint8_t> encode() {
        std::vector<std::uint8_t> result{};
        std::vector<std::uint8_t> aux{};

        {% for piece in impl.encoding | reverse %}
        {% if piece.type | is_enum %}
        aux = _encode(static_cast<{{piece | enum_underlying_type}}>({{piece.name}}));
        {%- elif piece.type | is_builtin -%}
        aux = _encode({{piece.name}});
        {% elif piece.type | is_array -%}
        aux = encode_array<{{piece.type.type | to_cpp_type}}, {{piece.type.size}}>({{piece.name}});
        {% endif -%}
        result.insert(result.begin(), aux.rbegin(), aux.rend());
        {% endfor %}
        return result;
    }
    {% endif %}
};

inline bool operator==(const {{struct.name}}& lhs, const {{struct.name}}& rhs)
{
    return{% for signal in struct.fields %} lhs.{{signal.name}} == rhs.{{signal.name}} &&{% endfor %} true;
}

{% endfor -%}
} // namespace fcp

#endif // __FCP_CAN_H__
