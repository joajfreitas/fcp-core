#pragma once

#include <map>
#include <any>
#include <cstdint>
#include <string>
#include <optional>
#include <cstring>
#include <utility>

#include <nlohmann/json.hpp>

#include "fcp.h"
#include "i_can_schema.h"

namespace fcp {
namespace can {

using json = nlohmann::json;

inline bool operator==(const frame_t& lhs, const frame_t& rhs) {
    return lhs.bus == rhs.bus &&
            lhs.sid == rhs.sid &&
            lhs.dlc == rhs.dlc &&
            lhs.data == rhs.data;
}


struct Can {
    Can(ICanSchema& schema): schema_{schema} {}

    std::optional<std::pair<std::string,json>> Decode(const frame_t& frame) {
        return schema_.Decode(frame);
    }

    std::optional<frame_t> Encode(std::string msg_name, json j) {

        {% for impl in fcp.get_matching_impls('can') %}
        if (msg_name == "{{impl.name}}") {
            return BuildMessage("{{impl.fields.get('bus')}}", {{impl.fields.get('id')}}, {{impl.type}}::FromJson(j).Encode().GetData());
        }
        {% endfor %}

        return std::nullopt;
    }

  private:
    frame_t BuildMessage(std::string bus_name, std::uint16_t sid, std::vector<uint8_t> data) {
        frame_t frame{};
        std::copy(bus_name.begin(), bus_name.end(), frame.bus.data());
        frame.sid = sid;
        frame.dlc = data.size();
        std::copy(data.begin(), data.end(), frame.data.begin());
        return frame;
    }

    ICanSchema& schema_;
};

} // namesapce can
} // namespace fcp
