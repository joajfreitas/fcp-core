#ifndef {{ device_name_upper }}_RPC_H
#define {{ device_name_upper }}_RPC_H

#include <stdint.h>
#include <stdbool.h>
#include "can_frame.h"

/*---------------------------------------- Type Definitions ----------------------------------------*/

#define {{ device_name_snake | upper }}_RPC_GET_ID {{ rpc_get_id }}
#define {{ device_name_snake | upper }}_RPC_ANS_ID {{ rpc_ans_id }}

#define MAX_RPC_ENTRIES {{ rpcs|length }}

typedef union {
    struct {
        uint8_t service_id;
        uint8_t method_id;
    };
    uint16_t rpc_id;
} CanRpcId;


/**
 * @brief RPC handler function prototype.
 * 
 * Each handler should process an incoming frame and fill out the response.
 * 
 * @param request  Pointer to the incoming CAN frame.
 * @param response Pointer to the CAN frame that will be filled as the response.
 */
typedef void (*{{ device_name_pascal }}RpcHandler)(const CanFrame *request, CanFrame *response);

/*---------------------------------------- RPC Utility Functions -----------------------------------*/

/**
 * @brief Check if a CAN frame belongs to this device's RPC namespace.
 */
bool is_{{ device_name_snake }}_rpc(const CanFrame *frame);

/**
 * @brief Main RPC dispatcher.
 * 
 * Finds and invokes the handler corresponding to a service + method ID.
 * Automatically sends back a response using the provided callback.
 */
void {{ device_name_snake }}_service_dispatch(
    const CanFrame *frame,
    void (*send_func)(const CanFrame *)
);

/*---------------------------------------- RPC Registration API ------------------------------------*/

/**
 * @brief Register an RPC handler dynamically.
 * 
 * Adds or updates a handler in the internal RPC table.
 * 
 * @param service_id RPC service identifier.
 * @param method_id  RPC method identifier.
 * @param handler    Function pointer to the handler.
 * @return true if successfully registered or updated, false otherwise.
 */
bool {{ device_name_snake }}_rpc_register(uint8_t service_id, uint8_t method_id, {{ device_name_pascal }}RpcHandler handler);

/**
 * @brief Unregister an RPC handler dynamically.
 * 
 * Removes the handler associated with the given service and method IDs.
 * 
 * @param service_id RPC service identifier.
 * @param method_id  RPC method identifier.
 * @return true if successfully unregistered, false if not found.
 */
bool {{ device_name_snake }}_rpc_unregister(uint8_t service_id, uint8_t method_id);

/**
 * @brief Initialize and pre-register all statically generated RPC handlers.
 * 
 * Should be called once during system startup.
 */
void {{ device_name_snake }}_rpc_init(void);

/*---------------------------------------- RPC Encode/Decode Prototypes -----------------------------*/
{% for message in rpcs %}
typedef struct {
    {% for signal in message.signals %}
    {% if signal.multiplexer_count > 1 %}
    {{ signal.scalar_type }} {{ signal.name }}[{{ signal.multiplexer_count }}];
    {% else %}
    {{ signal.scalar_type }} {{ signal.name }};
    {% endif %}
    {% endfor %}
} CanRpc{{ message.name_pascal }};

CanRpc{{ message.name_pascal }} can_decode_rpc_{{ message.name_snake }}(const CanFrame *rpc);
CanFrame can_encode_rpc_{{ message.name_snake }}(const CanRpc{{ message.name_pascal }} *rpc{% if message.is_multiplexer %}, uint32_t {{ message.multiplexer_signal }}{% endif %});
CanFrame can_encode_rpc_{{ message.name_snake }}_ans(const CanRpc{{ message.name_pascal }} *rpc);
{% endfor %}

/*---------------------------------------- Generated Service Handlers -------------------------------*/
{% for service in services %}
{% for method in service.methods %}
/**
 * @brief Handler for {{ service.name }}.{{ method.name }} RPC method.
 */
void {{ device_name_snake }}_service_handle_{{ method.name_snake }}(const CanFrame *request, CanFrame *response);
{% endfor %}
{% endfor %}

#endif /* {{ device_name_upper }}_RPC_H */
