#ifndef {{ device_name_snake | upper }}_RPC_H
#define {{ device_name_snake | upper }}_RPC_H

#include <stdint.h>
#include <stdbool.h>
#include "can_frame.h"

/* RPC Get and Answer IDs */
#define {{ device_name_snake | upper }}_RPC_GET_ID {{ rpc_get_id }}
#define {{ device_name_snake | upper }}_RPC_ANS_ID {{ rpc_ans_id }}

/* Maximum Payload Size */
#define MAX_RPC_PAYLOAD_SIZE {{ max_payload_size }}

/* RpsMethod union */
typedef union {
    struct {
        uint8_t service;
        uint8_t method;
    };
    uint16_t service_method;
} RpcMethod;

/* RPC Message Can Struct */
typedef struct {
    RpcMethod method;
    uint8_t args[MAX_RPC_PAYLOAD_SIZE];
} RpcMessage;

/* Rpc Message Struct */
{%- for message in messages %}
typedef struct {
    {%- for signal in message.signals %}
    {{ signal.data_type }} {{ signal.name }}{% if signal.is_multiplexer %}[{{ signal.multiplexer_count }}]{% endif %};
    {%- endfor %}
} CanRpc{{ message.name_pascal }};
{%- endfor %}

/* Dispatcher */
void can_service_dispatch(const CanFrame *frame, void (*send)(const CanFrame *));

/* Functions to decode CanFrame into CanRpc<name> objects */
{%- for message in messages %}
CanRpc{{ message.name_pascal }} can_decode_rpc_{{ message.name_snake }}(const CanFrame *frame);
{%- endfor %}

/* Functions to encode CanRpc<name> object into CanFrame */
{%- for message in messages %}
{%- if message.is_multiplexer %}
CanFrame can_encode_rpc_{{message.name_snake}}(const CanRpc{{ message.name_pascal }} *rpc, uint32_t {{message.multiplexer_signal}});
{%- else %}
CanFrame can_encode_rpc_{{message.name_snake}}(const CanRpc{{ message.name_pascal }} *rpc);
CanFrame can_encode_rpc_{{message.name_snake}}_ans(const CanRpc{{ message.name_pascal }} *rpc);
{%- endif %}
{%- endfor %}

#endif // {{ device_name_snake | upper }}_RPC_H