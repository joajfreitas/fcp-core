#include "{{ device_name_snake }}_rpc.h"
#include "{{ device_name_snake }}_can.h"
#include <string.h>

/*---------------------------------------- RPC Validation Functions ------------------------------------------*/
bool is_valid_rpc_message(const CanFrame *frame) {
    if (!frame) return false;

    if (frame->id != {{ device_name_snake | upper }}_RPC_GET_ID &&
        frame->id != {{ device_name_snake | upper }}_RPC_ANS_ID) {
        return false;
    }

    return true;
}

/*--------------------------------------------- RPC Dispatcher ----------------------------------------------*/
void can_service_dispatch(const CanFrame *frame, void (*send)(const CanFrame *)) {
    if (!is_valid_rpc_message(frame)) return;

    CanFrame response;
    response.id = {{ device_name_snake | upper }}_RPC_ANS_ID;
    response.dlc = sizeof(RpcMessage);
    memset(response.data, 0, sizeof(response.data));

    const RpcMessage *req = (const RpcMessage *) frame->data;
    RpcMessage *res = (RpcMessage *) response.data;

    extern void can_service_handle(const RpcMessage *request, RpcMessage *response);
    can_service_handle(req, res);

    if (send) {
        send(&response);
    }
}

/*--------------------------------------------- Decode Signals ----------------------------------------------*/
{%- for message in messages %}
{%- for signal in message.signals %}
#define can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc) \
    can_decode_signal_as_{{ signal.scalar_type }}((rpc), {{ signal.start_bit }}, {{ signal.bit_length }}, {{ signal.scale }}, {{ signal.offset }}, {{ signal.is_big_endian_s }});
{%- endfor %}
{%- endfor %}

/*--------------------------------------------- Encode Signals ----------------------------------------------*/
{%- for message in messages %}
{%- for signal in message.signals %}
#define can_encode_signal_{{message.name_snake}}_{{signal.name}}(signal) \
    can_encode_signal_from_{{signal.scalar_type}}((signal), {{ signal.start_bit }}, {{ signal.bit_length }}, {{ signal.scale }}, {{ signal.offset }}, {{ signal.is_big_endian_s }});
{%- endfor %}
{%- endfor %}

{% for message in messages %}
/*-------------------------------------------- Decode Function ----------------------------------------------*/
CanRpc{{ message.name_pascal }} can_decode_rpc_{{ message.name_snake }}(const CanFrame *rpc) {
	CanRpc{{message.name_pascal}} rpc_struct = {0};

	{%- for signal in message.signals %}
	{%- if signal.multiplexer_count <= 1 %}
	rpc_struct.{{ signal.name }} = can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc);
	{%- endif %}
	{%- endfor %}

	{%- for signal in message.signals %}
	{%- if signal.multiplexer_count > 1 %}
	rpc_struct.{{ signal.name }}[rpc_struct.{{ signal.multiplexer_signal }}] = can_decode_{{ message.name_snake }}_{{ signal.name }}(rpc);
	{%- endif %}
	{%- endfor %}

	return rpc_struct;
}
{% endfor -%}

{%- for message in messages %}
/*-------------------------------------------- Encode Functions ---------------------------------------------*/
{%- if message.is_multiplexer %}
CanFrame can_encode_rpc_{{message.name_snake}}(const CanRpc{{ message.name_pascal }} *rpc, uint32_t {{message.multiplexer_signal}}) {
    CanFrame message = {.id = {{message.frame_id}}, .dlc = {{message.dlc}}};
    uint64_t word = 0;
    uint64_t *ptr = (uint64_t *) &message.data;
    {% for signal in message.signals %}
    {%- if signal.multiplexer_count > 1 -%}
    word |= can_encode_{{message.name_snake}}_{{signal.name}}(rpc->{{signal.name}}[{{message.multiplexer_signal}}]);
    {%- elif signal.name == message.multiplexer_signal %}
    word |= can_encode_signal_{{message.name_snake}}_{{signal.name}}({{message.multiplexer_signal}});
    {%- else -%}
    word |= can_encode_signal_{{message.name_snake}}_{{signal.name}}(rpc->{{signal.name}});
    {%- endif %}
    {% endfor %}
    *ptr = word;
    return message;
}
{%- else %}
CanFrame can_encode_rpc_{{message.name_snake}}(const CanRpc{{ message.name_pascal }} *rpc) {
	CanFrame message = {.id = {{ device_name_snake | upper }}_RPC_GET_ID, .dlc = {{message.dlc}}};
	uint64_t word = 0;
	uint64_t *ptr = (uint64_t *) &message.data;

	{% for signal in message.signals %}
	{%- if signal.multiplexer_count > 1 -%}
	word |= can_encode_signal_{{message.name_snake}}_{{signal.name}}(rpc->{{signal.name}}[rpc->{{signal.multiplexer_signal}}]);
	{%- else -%}
	word |= can_encode_signal_{{message.name_snake}}_{{signal.name}}(rpc->{{signal.name}});
	{%- endif %}
	{% endfor %}
	*ptr = word;
	return message;
}

CanFrame can_encode_rpc_{{message.name_snake}}_ans(const CanRpc{{ message.name_pascal }} *rpc) {
    CanFrame message = {.id = {{ device_name_snake | upper }}_RPC_ANS_ID, .dlc = {{message.dlc}}};
    uint64_t word = 0;
    uint64_t *ptr = (uint64_t *) &message.data;

    {% for signal in message.signals %}
    {%- if signal.multiplexer_count > 1 -%}
    word |= can_encode_signal_{{message.name_snake}}_{{signal.name}}(rpc->{{signal.name}}[rpc->{{signal.multiplexer_signal}}]);
    {%- else -%}
    word |= can_encode_signal_{{message.name_snake}}_{{signal.name}}(rpc->{{signal.name}});
    {%- endif %}
    {% endfor %}
    *ptr = word;
    return message;
}
{%- endif %}
{% endfor %}