#include "{{ device_name_snake }}_rpc.h"
#include "{{ device_name_snake }}_can.h"
#include "can_signal_parser.h"
#include <string.h>

/*---------------------------------------- RPC Validation ------------------------------------------*/
bool is_{{ device_name_snake }}_rpc(const CanFrame *frame) {
    if (!frame) return false;
    return (frame->id == {{ device_name_snake | upper }}_RPC_GET_ID ||
            frame->id == {{ device_name_snake | upper }}_RPC_ANS_ID);
}

/*---------------------------------------- Decode / Encode Signals ---------------------------------*/
{% for message in rpcs %}
{% for signal in message.signals %}
#define can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc) \
    can_decode_signal_as_{{ signal.scalar_type }}((rpc), {{ signal.start_bit + 16 }}, {{ signal.bit_length }}, {{ signal.scale }}, {{ signal.offset }}, {{ signal.is_big_endian_s }});

#define can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(signal) \
    can_encode_signal_from_{{ signal.scalar_type }}((signal), {{ signal.start_bit + 16 }}, {{ signal.bit_length }}, {{ signal.scale }}, {{ signal.offset }}, {{ signal.is_big_endian_s }});
{% endfor %}
{% endfor %}

/*---------------------------------------- Decode / Encode RPC Structs -------------------------------*/
{% for message in rpcs %}
CanRpc{{ message.name_pascal }} can_decode_rpc_{{ message.name_snake }}(const CanFrame *rpc) {
    CanRpc{{ message.name_pascal }} r = {0};

    {% for signal in message.signals %}
    {% if signal.multiplexer_count <= 1 %}
    r.{{ signal.name }} = can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc);
    {% else %}
    r.{{ signal.name }}[r.{{ message.multiplexer_signal }}] = can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc);
    {% endif %}
    {% endfor %}

    return r;
}


CanFrame can_encode_rpc_{{ message.name_snake }}(const CanRpc{{ message.name_pascal }} *rpc{% if message.is_multiplexer %}, uint32_t {{ message.multiplexer_signal }}{% endif %}) {
    CanFrame frame = {.id = {{ device_name_snake | upper }}_RPC_GET_ID, .dlc = {{ message.dlc + 2 }}};
    uint64_t word = 0;
    uint64_t *ptr = (uint64_t *)&frame.data;
    {% for signal in message.signals %}
    {% if signal.multiplexer_count > 1 %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }}[{{ message.multiplexer_signal }}]);
    {% else %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }});
    {% endif %}
    {% endfor %}
    *ptr = word;
    return frame;
}

CanFrame can_encode_rpc_{{ message.name_snake }}_ans(const CanRpc{{ message.name_pascal }} *rpc) {
    CanFrame frame = {.id = {{ device_name_snake | upper }}_RPC_ANS_ID, .dlc = {{ message.dlc + 2 }}};
    uint64_t word = 0;
    uint64_t *ptr = (uint64_t *)&frame.data;
    {% for signal in message.signals %}
    {% if signal.multiplexer_count > 1 %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }}[rpc->{{ message.multiplexer_signal }}]);
    {% else %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }});
    {% endif %}
    {% endfor %}
    *ptr = word;
    return frame;
}
{% endfor %}

/*---------------------------------------- RPC Table and Registry -----------------------------------*/
typedef struct {
    CanRpcId id;
    {{ device_name_pascal }}RpcHandler handler;
} {{ device_name_pascal }}RpcEntry;

static {{ device_name_pascal }}RpcEntry rpc_table[MAX_RPC_ENTRIES];
static size_t rpc_table_size = 0;
/*---------------------------------------- RPC Registration API ------------------------------------*/
bool {{ device_name_snake }}_rpc_register(uint8_t service, uint8_t method, {{ device_name_pascal }}RpcHandler handler) {
    if (!handler) return false;
    if (rpc_table_size >= MAX_RPC_ENTRIES) return false;

    for (size_t i = 0; i < rpc_table_size; i++) {
        if (rpc_table[i].id.service == service && rpc_table[i].id.method == method) {
            rpc_table[i].handler = handler;
            return true;
        }
    }

    rpc_table[rpc_table_size++] = ({{ device_name_pascal }}RpcEntry){
        .id = {.service = service, .method = method},
        .handler = handler,
    };
    return true;
}

bool {{ device_name_snake }}_rpc_unregister(uint8_t service, uint8_t method) {
    for (size_t i = 0; i < rpc_table_size; i++) {
        if (rpc_table[i].id.service == service && rpc_table[i].id.method == method) {
            memmove(&rpc_table[i], &rpc_table[i + 1], (rpc_table_size - i - 1) * sizeof(rpc_table[0]));
            rpc_table_size--;
            return true;
        }
    }
    return false;
}

/*---------------------------------------- RPC Lookup ----------------------------------------------*/
static {{ device_name_pascal }}RpcHandler find_rpc_handler(uint16_t rpc_id) {
    for (size_t i = 0; i < rpc_table_size; i++) {
        if (rpc_table[i].id.rpc_id == rpc_id)
            return rpc_table[i].handler;
    }
    return NULL;
}

/*---------------------------------------- RPC Dispatch ---------------------------------------------*/
void {{ device_name_snake }}_service_dispatch(
    const CanFrame *frame,
    void (*send_func)(const CanFrame *)
) {
    if (!frame || !is_{{ device_name_snake }}_rpc(frame)) return;
    if (frame->dlc < 2) return;

    CanRpcId id = {.service = frame->data[0], .method = frame->data[1]};
    {{ device_name_pascal }}RpcHandler handler = find_rpc_handler(id.rpc_id);
    if (!handler) return;

    CanFrame response = {0};
    handler(frame, &response);

    if (send_func) send_func(&response);
}

/*---------------------------------------- RPC Auto-Registration (Optional) -------------------------*/
void {{ device_name_snake }}_rpc_init(void) {
{% for service in services %}
    {% for method in service.methods %}
    {{ device_name_snake }}_rpc_register({{ service.id }}, {{ method.id }}, {{ device_name_snake }}_service_handle_{{ method.name_snake }});
    {% endfor %}
{% endfor %}
}
