#include "{{ device_name_snake }}_rpc.h"
#include "{{ device_name_snake }}_can.h"
#include "can_signal_parser.h"
#include <string.h>

/*---------------------------------------- RPC Validation ------------------------------------------*/
bool is_{{ device_name_snake }}_rpc(const CanFrame *frame) {
    if (!frame) return false;
    return (frame->id == {{ device_name_snake | upper }}_RPC_GET_ID ||
            frame->id == {{ device_name_snake | upper }}_RPC_ANS_ID);
}

/*---------------------------------------- Decode / Encode Signals ---------------------------------*/
{% for message in rpcs %}
{% for signal in message.signals %}
#define can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc) \
    can_decode_signal_as_{{ signal.scalar_type }}((rpc), {{ signal.start_bit + 16 }}, {{ signal.bit_length }}, {{ signal.scale }}, {{ signal.offset }}, {{ signal.is_big_endian_s }});

#define can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(signal) \
    can_encode_signal_from_{{ signal.scalar_type }}((signal), {{ signal.start_bit + 16 }}, {{ signal.bit_length }}, {{ signal.scale }}, {{ signal.offset }}, {{ signal.is_big_endian_s }});
{% endfor %}
{% endfor %}

/*---------------------------------------- Decode / Encode RPC Structs -------------------------------*/
{% for message in rpcs %}
CanRpc{{ message.name_pascal }} can_decode_rpc_{{ message.name_snake }}(const CanFrame *rpc) {
    CanRpc{{ message.name_pascal }} r = {0};
    {% for signal in message.signals %}
    {% if signal.multiplexer_count <= 1 %}
    r.{{ signal.name }} = can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc);
    {% else %}
    r.{{ signal.name }}[r.{{ message.multiplexer_signal }}] = can_decode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc);
    {% endif %}
    {% endfor %}
    return r;
}

CanFrame can_encode_rpc_{{ message.name_snake }}(const CanRpc{{ message.name_pascal }} *rpc{% if message.is_multiplexer %}, uint32_t {{ message.multiplexer_signal }}{% endif %}) {
    CanFrame frame = {.id = {{ device_name_snake | upper }}_RPC_GET_ID, .dlc = {{ message.dlc + 2 }}};
    uint64_t word = 0;
    uint64_t *ptr = (uint64_t *)&frame.data;
    {% for signal in message.signals %}
    {% if signal.multiplexer_count > 1 %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }}[{{ message.multiplexer_signal }}]);
    {% else %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }});
    {% endif %}
    {% endfor %}
    *ptr = word;
    return frame;
}

CanFrame can_encode_rpc_{{ message.name_snake }}_ans(const CanRpc{{ message.name_pascal }} *rpc) {
    CanFrame frame = {.id = {{ device_name_snake | upper }}_RPC_ANS_ID, .dlc = {{ message.dlc + 2 }}};
    uint64_t word = 0;
    uint64_t *ptr = (uint64_t *)&frame.data;
    {% for signal in message.signals %}
    {% if signal.multiplexer_count > 1 %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }}[rpc->{{ message.multiplexer_signal }}]);
    {% else %}
    word |= can_encode_signal_{{ message.name_snake }}_{{ signal.name }}(rpc->{{ signal.name }});
    {% endif %}
    {% endfor %}
    *ptr = word;
    return frame;
}
{% endfor %}

/*---------------------------------------- 2D RPC Handler Table -------------------------------------*/
typedef void (*{{ device_name_pascal }}RpcHandler)(const CanFrame *, CanFrame *);

#define MAX_SERVICES {{ services|length }}
#define MAX_METHODS 16  // adjust if you have more methods per service

static const {{ device_name_pascal }}RpcHandler handler_table[MAX_SERVICES][MAX_METHODS] = {
{% for service in services %}
    {
    {% for method in service.methods %}
        [{{ method.id }}] = {{ device_name_snake }}_service_handle_{{ method.name_snake }},
    {% endfor %}
    },
{% endfor %}
};

/*---------------------------------------- RPC Dispatch ---------------------------------------------*/
void {{ device_name_snake }}_service_dispatch(
    const CanFrame *frame,
    void (*send_func)(const CanFrame *)
) {
    if (!frame || !is_{{ device_name_snake }}_rpc(frame)) return;

    // DLC check: must have at least 2 bytes for service_id and method_id
    if (frame->dlc < 2) return;

    uint8_t service_id = frame->data[0];
    uint8_t method_id  = frame->data[1];

    if (service_id >= MAX_SERVICES) return;
    if (method_id >= MAX_METHODS) return;

    {{ device_name_pascal }}RpcHandler handler = handler_table[service_id][method_id];
    if (!handler) return;

    CanFrame response = {0};
    handler(frame, &response);

    if (send_func) send_func(&response);
}
